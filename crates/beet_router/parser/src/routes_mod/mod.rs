pub use crate::prelude::*;
use anyhow::Result;
use clap::Parser;
use std::path::PathBuf;
use sweet::prelude::*;
use syn::File;
mod file_routes;
use file_routes::FileRoutes;

/// Parse a 'routes' dir, collecting all the routes,
/// and create a `mod.rs` which contains
/// a [ServerRoutes] struct with all the routes.
#[derive(Debug, Parser)]
pub struct BuildRoutesMod {
	/// Optionally specify additional tokens to be added to the top of the file.
	#[arg(long)]
	pub file_router_tokens: Option<String>,
	/// Identifier for the router. The router must have
	/// where T can be a type or trait for each route on the site.
	#[arg(long, default_value = "beet::router::DefaultFileRouter")]
	pub file_router_ident: String,
	/// location of the src directory,
	#[arg(long, default_value = "src")]
	pub src: PathBuf,
	/// location of the routes directory relative to the src directory.
	/// This will be used to split the path and discover the route path,
	/// the last part will be taken so it should not occur in the path twice.
	/// ✅ `src/routes/foo/bar.rs` will be `foo/bar.rs`
	/// ❌ `src/routes/foo/routes/bar.rs` will be `routes/bar.rs`
	#[arg(long, default_value = "routes")]
	pub routes_dir: PathBuf,
}

impl Default for BuildRoutesMod {
	fn default() -> Self { clap::Parser::parse_from(&[""]) }
}

impl BuildRoutesMod {
	pub fn src_dir(&self) -> &PathBuf { &self.src }
	pub fn routes_dir(&self) -> PathBuf {
		self.src_dir().join(&self.routes_dir)
	}
	pub fn routes_mod_path(&self) -> PathBuf {
		self.routes_dir().join("mod.rs")
	}


	pub fn build_string(&self) -> Result<String> {
		let routes_dir_name = self.routes_dir.to_string_lossy();
		let page_routes = ReadDir::files_recursive(self.routes_dir())?
			.into_iter()
			.map(|path| FileRoutes::parse(&routes_dir_name, path))
			.collect::<Result<Vec<_>>>()?
			.into_iter()
			.flatten();

		let router_ident = &self.file_router_ident;
		let router_ident: syn::Type = syn::parse_str(router_ident).unwrap();

		// let ident_tokens =
		// let ident = syn::Ident::new(router_ident, Span::call_site());
		// let syn_path: syn::Path = parse_quote!(#router_ident);
		// let syn_path = syn_path.to_token_stream();

		let prefix_tokens: File = self
			.file_router_tokens
			.as_ref()
			.map(|tokens| syn::parse_str(tokens))
			.unwrap_or_else(|| {
				Ok(syn::parse_quote! {
					//! 🥁🥁🥁 This file has been auto generated by the Beet router.
					//! 🥁🥁🥁 Any changes will be overridden if the file is regenerated.
					use beet::prelude::*;
				})
			})?;

		let file: File = syn::parse_quote! {
			#prefix_tokens
			pub fn collect_file_routes(router: &mut #router_ident) {
				#(
					router.add_route(#page_routes);
				)*
			}
		};
		let file = prettyplease::unparse(&file);

		Ok(file)
	}


	pub fn build_and_write(&self) -> Result<()> {
		let data = self.build_string()?;
		FsExt::write(self.routes_mod_path(), &data)?;
		Ok(())
	}
}


#[cfg(test)]
mod test {
	// indirectly testd via build_test_site.rs
}
