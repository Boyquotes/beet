use super::RouteBuilder;
use anyhow::Result;
use std::path::PathBuf;
use sweet::prelude::*;
use syn::File;

pub struct RoutesFileBuilder {
	/// location of the src directory,
	/// if empty defaults to $CARGO_MANIFEST_DIR/src
	src_dir: Option<PathBuf>,
	/// location of the pages directory relative to the src directory
	/// if empty defaults to `pages`
	pages_dir: Option<PathBuf>,
	/// location of the routes file relative to the src directory
	/// if empty defaults to `routes.rs`
	routes_file: Option<PathBuf>,
}

impl Default for RoutesFileBuilder {
	fn default() -> Self {
		Self {
			pages_dir: Default::default(),
			routes_file: Default::default(),
			src_dir: Default::default(),
		}
	}
}

impl RoutesFileBuilder {
	pub fn with_src_dir(src_dir: PathBuf) -> Self {
		Self {
			src_dir: Some(src_dir),
			..Default::default()
		}
	}


	fn src_dir(&self) -> PathBuf {
		self.src_dir.clone().unwrap_or_else(|| {
			std::env::var("CARGO_MANIFEST_DIR")
				.map(|dir| Into::<PathBuf>::into(dir).join("src"))
				.unwrap_or_else(|_| "src".into())
		})
	}

	fn pages_dir(&self) -> PathBuf {
		self.src_dir()
			.join(self.pages_dir.clone().unwrap_or("pages".into()))
	}

	fn routes_file(&self) -> PathBuf {
		self.src_dir()
			.join(self.routes_file.clone().unwrap_or("routes.rs".into()))
	}

	pub fn write_to_file(&self) -> Result<()> {
		let routes = self.build_file()?;
		let routes_file = self.routes_file();
		std::fs::write(&routes_file, routes)?;
		Ok(())
	}

	pub fn build_file(&self) -> Result<String> {
		let page_routes = ReadDir::files_recursive(self.pages_dir())?
			.iter()
			.map(|path| RouteBuilder::map_routes(&path))
			.collect::<Result<Vec<_>>>()?
			.into_iter()
			.flatten();

		let file: File = syn::parse_quote! {
			//! 🥁🥁🥁 This file has been auto generated by the Beet router.
			//! 🥁🥁🥁 Any changes will be overridden if the file is regenerated.
			use beet::prelude::*;
			pub fn routes() -> Vec<Route> {
				vec![
					#(#page_routes),*
				]
			}
		};
		let file = prettyplease::unparse(&file);

		Ok(file)
	}


	pub fn build_and_write(&self) -> Result<()> {
		let data = self.build_file()?;
		ReadFile::write(self.routes_file(), &data)?;
		Ok(())
	}


	#[cfg(test)]
	fn for_beet_site() -> Self {
		let workspace_root = FsExt::workspace_root();
		let src_dir = workspace_root.join("crates/beet_site/src");
		Self::with_src_dir(src_dir)
	}
}


#[cfg(test)]
mod test {
	use crate::prelude::*;

	#[test]
	fn works() {
		let routes_file = RoutesFileBuilder::for_beet_site();
		routes_file.build_and_write().unwrap();
		// expect(CompileCheck::file(&routes_file.routes_file())).to_be_ok();


		let _routes = RoutesFileBuilder::for_beet_site().build_file().unwrap();

		// println!("{}", routes);
	}
}
